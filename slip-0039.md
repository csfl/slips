# SLIP-0039 : Shamir's Secret-Sharing for Mnemonic Codes

```
Number:  SLIP-0039
Title:   Shamir's Secret-Sharing for Mnemonic Codes
Type:    Standard
Status:  Draft
Authors: Pavol Rusnak <stick@satoshilabs.com>
         Ondrej Vejpustek <ondrej.vejpustek@satoshilabs.com>
         Tomas Susanka <tomas.susanka@satoshilabs.com>
         Marek Palatinus <slush@satoshilabs.com>
         Jochen Hoenicke <hoenicke@gmail.com>
         Andrew Kozlik <andrew.kozlik@satoshilabs.com>
Created: 2017-12-18
```

## Abstract

This SLIP describes a standard and interoperable implementation of Shamir's secret-sharing (SSS). SSS divides a secret into unique parts which can be distributed among participants, and requires a specified minimum number of parts be supplied in order to reconstruct the original secret. Knowledge of fewer than the required number of parts does not leak information about the secret.

## Motivation

Preservation of digital assets is generally important and it is especially important in the case of decentralized payments systems such as Bitcoin, where there is no recourse in the case of loss of an asset. The usual approach to protecting digital assets is redundant backups, but when the asset itself is of significant and liquidable value, there is a substantial risk of the backup holder absconding with the asset. Shamir's secret-sharing provides a better mechanism for replicating secrets, by distributing custodianship among a number of trusted parties in a manner that can prevent loss even if one or a few of those parties become compromised.

However, the lack of SSS standardization to date presents a risk of being unable to perform secret recovery in the future should the tooling change. Therefore, we propose standardizing SSS so that SLIP-0039 compatible implementations will be interoperable.

## Shamir's secret-sharing

Shamir's secret-sharing (SSS) is a cryptographic mechanism describing how to divide a secret into *N* unique parts, where any *T* of them are required to reconstruct the secret. First, a polynomial *f* of degree *N*&minus;1 is constructed and each party is given a corresponding point - a non-zero integer *x* input to the polynomial and the corresponding output *f*(*x*).

When sufficient *T* values are provided the points exactly define the polynomial. The polynomial's value of *f*(0) = *PMS* corresponds to the pre-master secret. More detail on SSS can be found on [Wikipedia](https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing).

![curve](slip-0039/curve.png)

## Generating the mnemonic shares

The value to be encoded as the master secret must be a multiple of 16 bits. This is typically a master seed for a hierarchical deterministic wallet, but may be another secret value which was chosen from its key space randomly with a uniform distribution. The master secret is first encrypted to a pre-master secret using a passphrase. The pre-master secret is divided into *N* Shamir parts and *T* specifies how many of those parts are needed to reconstruct the pre-master secret. We use GF(256) reduced by *x*<sup>8</sup> + *x*<sup>4</sup> + *x*<sup>3</sup> + *x* + 1 (the Rijndael polynomial) as the underlying finite field<sup>[2](#FiniteField)</sup>.

We propose the following format of the shares:

| identifier (*id*) | threshold (*t*) | index (*I*) | share (*s*) | checksum (*C*) |
|-------------------|-----------------|-------------|-------------|----------------|
| 20 bits           | 5 bits          | 5 bits      | 8*n* bits   | 30 bits        |

* identifier (*id*) field is a random 20-bit value which is the same for all shares and used to detect whether the shares belong together; it's also used as salt in key derivation functions.
* threshold (*t*) field<sup>[1](#IndexEncoding)</sup> indicates how many shares are needed to reconstruct the secret. The actual value is encoded as *t*=*T*&minus;1, so a value of 0 indicates that a single share is needed (*T*=1), a value of 1 indicates that two shares are needed (*T*=2) etc.
* index (*I*) field<sup>[1](#IndexEncoding)</sup> corresponds to the SSS part's *x* value, *x*=*I*+1, (see the diagram above).
* share (*s*) field is the corresponding SSS part's *f*(*x*) values (see the diagram above), right-padded with "0" bits so that the length of the padded share in bits becomes a multiple of ten. In all, at most eight bits are appended.
* checksum (*C*) field is an RS1024 checksum (see below) of the data part of the share (that is *id* || *t* || *I* || *s*); the human-readable part (hrp) of RS1024 is "slip0039"

This structure is then converted into a mnemonic code by splitting it up into 10 bit segments with each becoming an index to a word list containing exactly 1024 words (see below).

| share length | total length           | security |
|--------------|------------------------|----------|
| 130 bits     | 190 bits = 19 words    | 128 bits |
| 260 bits     | 320 bits = 32 words    | 256 bits |

This construction yields a beneficial property where the identifier transforms into exactly the first two words of the mnemonic code, so the user can immediately tell whether the correct shares are being combined (i.e. they have to have the same first two words). Moreover, the third word encodes exactly the index/threshold values, so for example share #2 of 3 required shares will always correspond to the same word.

## Checksum
The last three words of the mnemonic form a checksum and contain no information. Valid mnemonics MUST pass the criteria for validity specified by the Python3 code snippet below. The function `rs1024_verify_checksum` must return true when its arguments are:

- `hrp`: the human-readable part as a string
- `data`: the data part as a list of integers representing the words after conversion using the wordlist

```
def rs1024_polymod(values):
  GEN = [0xe0e040, 0x1c1c080, 0x3838100, 0x7070200, 0xe0e0009, 0x1c0c2412, 0x38086c24, 0x3090fc48, 0x21b1f890, 0x3f3f120]
  chk = 1
  for v in values:
    b = (chk >> 20)
    chk = (chk & 0xfffff) << 10 ^ v
    for i in range(10):
      chk ^= GEN[i] if ((b >> i) & 1) else 0
  return chk

def rs1024_verify_checksum(hrp, data):
  return rs1024_polymod([ord(x) for x in hrp] + data) == 1
```

This implements a Reed-Solomon code over GF(1024) that guarantees detection of any error affecting at most 3 words and has less than a 1 in 10<sup>9</sup> chance of failing to detect more errors. More details about the properties can be found in the Checksum Design appendix<sup>[6](#ChecksumDesign)</sup>. The human-readable part is processed by feeding each character's US-ASCII value into the checksum calculation prior to the data.

To construct a valid checksum given the human-readable part and (non-checksum) values of the data-part words, the code below can be used:

```
def rs1024_create_checksum(hrp, data):
  values = [ord(x) for x in hrp] + data
  polymod = rs1024_polymod(values + [0,0,0]) ^ 1
  return [(polymod >> 10 * (2 - i)) & 1023 for i in range(3)]
```

## Converting the mnemonic shares to the pre-master secret

First, we check the checksum of each share and abort if they don't match. Implementations SHOULD NOT implement correction beyond potentially suggesting to the user where in the string an error might be found, without suggesting the correction to make.

If the checksum of each share is correct and a sufficient number of shares *k* have been provided, *k*&ge;*T*, the pre-master secret *PMS* can be computed using Lagrange interpolation:

![\mathit{PMS} = {\sum_{i=0}^{k-1}} s_i {\prod_{\underset{j \neq i}{j=0}}^{k-1}} \frac{x_j}{x_j - x_i}](slip-0039/lagrange.png)

## Passphrase

To allow additional protection of the master secret using a passphrase, a strong pseudorandom permutation<sup>[3](#StrongPRP)</sup> is used. If no passphrase is provided, then an empty string should be used as the passphrase.

A passphrase should contain only printable ASCII characters (codepoints 32-126) to achieve the best interoperability among various operating systems and wallet implementations.

The strong pseudorandom permutation uses the Luby-Rackoff construction which consists of a four round Feistel network with PBKDF2 as the round function. The pre-master secret is first split into two equally long parts. `L` is the first *n*/2 octets of the pre-master secret and `R` is the last *n*/2 octets of the pre-master secret.

![feistel](slip-0039/feistel.png)

```
L = PMS[:len(PMS)/2]
R = PMS[len(PMS)/2:]
for i in range(4):
    (L, R) = (R, L xor F(R))
```
The master secret is then `R || L`.

The round function `F(R)` is defined as follows<sup>[4](#KDFParam)</sup>:
```
F(R) = PBKDF2(PRF = HMAC-SHA256, Password = (passphrase || i), Salt = ("slip0039" || id || T || R), iterations = 5000, dkLen = n/2 octets)
```
The random identifier value *id* is encoded as two lowercase words from the wordlist separated by exactly one space (codepoint 32).

The master secret can be used as the master seed *S* for Hierarchical Deterministic Wallets described in BIP-0032.

## ALTERNATIVE PASSPHRASE PROTECTION METHODS
The solution proposed in the Passphrase section is still under discussion. This section discusses the possible alternatives that are under consideration.

### CMC mode
Use PBKDF2 to derive an encryption key and then encrypt the pre-master secret using AES in CMC mode (CBC-mask-CBC), see [S. Halevi, P. Rogaway: A Tweakable Enciphering Mode](https://eprint.iacr.org/2003/148.pdf). The input/output size for AES-CMC is limited to 16*m* bytes, where *m*&ge;2. For *m*=1 we can use plain AES.

Advantages:

- CMC mode works as a strong pseudorandom permutation just like the Feistel solution.
- Allows the user to choose the master secret just like the Feistel solution.
- Appears to be more solid than the Feistel solution in the sense that the Feistel solution looks like we are rolling our own cryptography.

Disadvantages:

- The length of the master secret is limited to multiples of 128 bits.
- The CMC solution is slightly more complicated to implement than the Feistel solution.

### CMC mode with ciphertext stealing
Use PBKDF2 to derive an encryption key and then encrypt the pre-master secret using AES in CMC mode with ciphertext stealing. Ciphertext stealing would first be used in the top CBC layer and then again in the bottom CBC layer.

The advantages and disadvantages are the same as for CMC mode with the exception of these differences:

Advantages:

- Allows the user to choose a master secret of any length *m* bits, where *m*&ge;128.

Disadvantages:

- Ciphertext stealing was not considered in the CMC paper so this modification can be perceived as rolling our own cryptography.

### AES with a standard length-preserving mode
Use PBKDF2 to derive an encryption key and IV from the passpharse and then encrypt the pre-master secret using a standard length-preserving mode such as CTR, CFB or CBC with ciphertext stealing.

Advantages:

- Allows user to choose the master secret.

Disadvantages:

- Doesn't solve the issue, where the adversary obtains partial knowledge of *T* different shares. See the [Rationale](#StrongPRP) section.

### PBKDF2 only, as in BIP-39
Use PBKDF2 the same way as it is used in BIP-39 to maintain backwards compatibility.

Advantages:

- Users can easily migrate from their BIP-32 wallets.

Disadvantages:

- It is not possible to choose the master secret.
- The PBKDF2 security parameters used in BIP-32 are rather weak.

### PBKDF2 only, with updated parameters
Use PBKDF2 the same way as it is used in BIP-39, but with updated parameters PRF = HMAC-SHA-256, iterations = 20000.
  
Advantages:

- Simplicity.

Disadvantages:

- It is not possible to choose the master secret. This limits the use cases and may be an obstacle for some users in migrating their BIP-32 wallets.


## Versioning

Our scheme doesn't support versioning. This is intentional to avoid unclear claims such as SLIP-0039 compatibility without a clear understanding of which version of the scheme is actually meant.

## Localization

No localization is supported. This standard deals with a set of English words only. Previous attempts with arbitrary wordlists caused lots of confusion among users and decreased interoperability across various implementations.

## Wordlist

The wordlist mandated by this SLIP is [available here](slip-0039/wordlist.txt). Several criteria were applied in creation of the list:

* The wordlist is alphabetically sorted.
* No word is shorter than 4 letters.
* No word is longer than 8 letters.
* All words begin with a unique 4-letter prefix.
* The wordlist contains only common English words (+ the word "satoshi").
* The minimum Damerau-Levenshtein distance between any two words is at least 2.
* The similarity between the pronunciation of any two words has been minimised.

(see the [test](slip-0039/test_wordlist.sh) which checks whether these criteria are fulfilled).

## Test Vectors

TBD

## Design Rationale

1. <a name="IndexEncoding"></a>**Index encoding**

    It is anticipated that 32 shares will be more than enough for any application of Shamir's Secret Sharing Scheme to BIP-32 master seeds. Thus to reduce the mnemonic length, the Index and Threshold values are restricted to 5 bits each.

    The values in the Threshold and Index fields are interpreted in such a way that index 0 means *x*=1, index 1 means *x*=2 etc. If this convention was not applied and *x* would be exactly equal to the value in the index field, then 0 would have to be considered an invalid value. However, some implementations might fail to check this, which would open the door to the following attack: Assume that an implementation doesn't check that the supplied *x* value is non-zero. An attacker that has write access to one of the shares can then change the stored point from (*x*,*y*) to (0,*y*). If the implementation uses this value in the Lagrange interpolation formula, then the resulting pre-master secret will always be equal to *y* regardless of the values of the other shares. If this value is then used as a master seed for a BIP-32 wallet and the user transfers funds to this wallet, the attacker will be able to steal these funds because he knows *y*.


2. <a name="FiniteField"></a>**Choice of finite field**

    Finite fields of the form GF(2<sup>*n*</sup>) and GF(*p*), where *p* is a prime number, were considered for this scheme. The field GF(256) was chosen, because the field arithmetic is easy to implement in any programming language and many implementations are already available since it is used in the AES cipher. The fact that it is byte oriented makes it easy to work with.

    Using a field of prime order GF(*p*), where log<sub>2</sub> *p* is approximately the length of the secret in bits, would require support for multi-precision arithmetic. Many programming languages, such as C/C++, do not support multi-precision arithmetic out of the box. Implementations would also need to store information about the prime number that should be used for each admissible length of the secret or they would need to compute the prime number on the fly.

    Choosing GF(2<sup>*n*</sup>), where *n* is the length of the secret in bits would require a more complicated implementation than GF(256). This is in part due to the multi-precision nature of the arithmetic and in part due to the fact that implementations would need to store the lexicographically minimal irreducible polynomial of degree *n* for each admissible value of *n* or they would need to be able to compute this polynomial on the fly.

3. <a name="StrongPRP"></a>**Strong pseudorandom permutation**

    The reason why a strong pseudorandom permutation was chosen to protect the master secret is to thwart attacks where the adversary obtains, for example, the first several octets of *T* different shares. If the master secret were not protected by a pseudorandom permutation, the adversary could compute a part of the master secret. This is a serious concern if the master secret is, for example, a private key. Protecting the master secret using AES in any of the common block cipher modes does not solve this problem.

    It might appear that such attacks would not be possible had a lager finite field been used, such as GF(2<sup>*n*</sup>) or GF(*p*), where *n*&asymp;log<sub>2</sub> *p* and *n* is the length of the secret in bits. However, we are not aware of any proof that Shamir's secret sharing scheme is secure in scenarios where partial information about the shares is leaked. In fact, our preliminary investigation indicates that in certain cases information about the pre-master secret may leak if partial knowledge of *T* shares is available. Thus the use of a strong pseudorandom permutation is advisable regardless of the choice of the field.

    The role of the key derivation function in the Luby-Rackoff construction is twofold. Firstly, it protects the passphrase against brute-force and dictionary attacks. Secondly, if the adversary obtains a part of the pre-master secret as described above, the slow key derivation function protects against brute-force attacks which attempt to reveal the unknown part of the pre-master secret.


4. <a name="KDFParam"></a>**Choice of KDF function and parameters**

    PBKDF2 is a widely used standard password-based key derivation function. Newer key derivation functions such as scrypt or Argon2 were considered, but these require a large amount of memory, which is a limiting factor in hardware wallets.

    The number of iterations in PBKDF2 was chosen to be 5000. Since this PBKDF2 is called four times, there is a total of 20000 iterations. A larger number of iterations in PBKDF2 would impact the user experience in hardware wallets.

    The SHA-256 algorithm operates on 32-bit words, whereas the SHA-512 algorithm operates on 64-bit words. As a consequence SHA-512 is significantly faster on 64-bit platforms than on 32-bit platforms, but SHA-256 performs almost the same on both platforms. Using HMAC-SHA-512 would put the user who may be running on a 32-bit platform at a significant disadvantage against an attacker which is running a brute force attack on a 64-bit platform. This is why HMAC-SHA-256 was chosen as the pseudorandom function for PBKDF2.
    If the length of the master secret is limited to a maximum of 256 bits, then using HMAC-SHA-256 instead of HMAC-SHA-512 presents no weakness.  

5. <a name="PassphraseVerification"></a>**Passphrase verification**

    The proposed design does not provide a way to verify that the correct passphrase was used to decrypt the master secret. This is an intentional feature which allows the user to derive multiple master secrets from a single pre-master secret by using different passphrases. This design allows for plausible deniability when the master secret is used as the master seed for a hierarchical deterministic wallet (see BIP-32). Every passphrase generates a valid seed but only the correct one will make the desired wallet available. Thus the owner can use one passphrase to access their real wallet and another passphrase to access a decoy wallet. If the owner is later coerced into revealing their passphrase either by [law](https://en.wikipedia.org/wiki/Key_disclosure_law) or by force, then they can reveal the passphrase which accesses the decoy wallet and [plausibly deny](https://en.wikipedia.org/wiki/Plausible_deniability) the existence of their real wallet, because there is no way for the coercer to prove that the decoy wallet is not the real one.

6. <a name="ChecksumDesign">**Checksum design**

    The checksum design is heavily inspired by Bech32 defined in BIP-0173. The RS1024 checksum uses a Reed-Solomon code over GF(1024), so that the code alphabet matches the 10-bit wordlist. A Reed-Solomon code over GF(1024) allows creating mnemonics of length up to 1022 words, which is plenty. Shared secrets that would require such length are impractical for human entry and should be stored in binary form rather than mnemonic form. We picked 3 checksum words as a trade-off between the length of the mnemonics and the error-detection capabilities, as 3 checksum words is the lowest number sufficient for a random failure chance below 1 per billion. The chosen error-correcting code is an MDS code, which means that it is guaranteed to detect any 3 or fewer errors. This is the maximum possible for any kind of checksum that has length 3. Reed-Solomon codes can be viewed as a special case of BCH codes. In the Python3 code snippet we use the BCH view of Reed-Solomon codes, because it allows for a more efficient implementation of the algorithms.

## References

* [BIP-0032: Hierarchical Deterministic Wallets](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
* [Secret Sharing Step by Step by Point Software](http://www.pointsoftware.ch/en/secret-sharing-step-by-step/)
* [BIP-0173: Base32 address format for native v0-16 witness outputs](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#Bech32)
